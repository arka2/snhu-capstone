---
layout: post
title: "Enhancement One -- Unity Tooling"
author: "Arka Tu"
categories: 
tags: []
image: header-01.png
---
[GitHub Repository](https://github.com/arka2/cs465-fullstack)

## Briefly describe the artifact. What is it? When was it created?
This artifact is a modified version of the Unity 2D Tile Editor package. I’m part of the team developing Shards Between Us, and the default Tile Editor is missing features that would help speed up designing levels. This version of the package (1.0.0) was released in 2019.

## Justify the inclusion of the artifact in your ePortfolio. Why did you select this item? What specific components of the artifact showcase your skills and abilities in software development? How was the artifact improved?
As I want to go into technical art, I selected this artifact to showcase my ability to understand Unity tooling and to make efficient modifications to software. I made these modifications after inspecting the Tile Editor’s behavior and its classes, which follow object-oriented principles. Specifically, I added code to output the Z-positions of cells when using the Pick Tool, and I added additional shortcuts to make it easier to paint on different Z-positions. While I didn’t add a large amount of code, I needed to investigate the classes and how they’re each used to find what code I needed to change, which required me to understand inheritance and encapsulation. Regarding inheritance, while looking through the codebase, I tracked through different child classes until I found the necessary parent class. Regarding encapsulation, I found some functions that I thought I might be able to use, I realized that they were set to private. In the interest of security, I continued looking for other functions that I could access instead in a safer manner.

Because the Tile Editor seemed to be developed with top-down 2D tiles in mind, my team has had trouble using it. Shards Between Us is an isometric game, and all the art assets are 2D sprites. This can make it difficult to find the position of a tile that’s already been placed in a level, and it’s difficult to paint across the Z-axis. There have been multiple instances where we build levels and then don't actually use them for months. After we open those levels to edit them, we find that we placed tiles on Z-positions other than 0. We then have to fiddle with finding where the tiles were placed if we want to erase them. Additionally, I added more informational tooltips, such as including modifiers and shortcuts, some of which we didn’t know existed until I investigated the codebase, such as learning we can hold down 'Shift' while painting tiles to switch to the erase tool.

## Did you meet the course outcomes you planned to meet with this enhancement in Module One? Do you have any updates to your outcome-coverage plans?
The course outcomes I planned to meet with this artifact were:
1. Employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science
2. Design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound, and appropriately adapted to specific audiences and contexts
3. Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices (data structures and algorithms)
4. Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals (software engineering/design/database)
5. Develop a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources

For Course Outcome 1, I focused my efforts on enhancements to allow the entire team to contribute to designing levels. This allows us to more easily test out different ideas, which, in turn, allows the programmer more time to fix bugs and adjust mechanics as she won’t need to be the only one building levels. Up until recently, our programmer was the only one who built levels, which created a bottleneck when developing prototypes. With the code base refactored at the end of last year and additional tooling, including this artifact, more team members can create levels. We generally then playtest the levels together, and we also have coworking sessions where we'll test tooling as it's in progress. This also leads into Course Outcome 2. The work on this artifact allows us to more easily show one another our ideas rather than needing to write or sketch them out. We also can make quicker decisions when we actually see levels in-engine, espeically since we can talk ourselves in circles developing the narrative.

For Course Outcome 3, I followed the original design of the Unity package, only changing as much as was necessary. I also implemented a simple algorithm to calculate the positions of the tiles that were directly over or under the selected cell. Lastly, I considered trade-offs when needing to identify how to approach painting across the Z-axis. Originally, I had wanted to allow the user to hold a modifier while painting, which would allow them to paint across a different plane. This proved to be more difficult than I expected, and, once I learned that shortcuts existed to change the Z-position, I pivoted to editing the shortcuts. This reduced the time I put into this one task, which allowed me to spend more time on other tasks.

For Course Outcome 4, I edited Unity Tooling to suit the needs of my team, which is necessary in game development. Default software likely won’t be enough for a game development team, and modifying the tools available allow for easier development.

For Course Outcome 5, I adopted a security mindset by keeping classes encapsulated, which in turn protects the classes’ data. This prevents accidental and malicious changes to data, both of which can cause defects. I wanted to keep the package's methods private, provided they were already private, to prevent any later tooling modifications from accidentally modifying the same data, which might conflict with the tooling developed for this artifact.

## Reflect on the process of enhancing and modifying the artifact. What did you learn as you were creating it and improving it? What challenges did you face?
When I initially started looking through the Tile Editor code, I found it difficult to find the pieces that needed. There were a lot of classes to sort through, so I started clicking through them to find out how they interacted with each other. Unfortunately, while some of the Tile Editor’s features are documented, most of the underlying code is not. As a result, I ended up using a lot of debug statements to find which part of the GUI was linked to each class. I also had difficulty finding how shortcuts are implemented, but after searching through the code again, I found that Tile Editor package stores shortcuts specific to the package in GridPaintPaletteWindow.cs. It’s possible to add custom shortcuts to Unity, but the function I needed to call was encapsulated, so I couldn’t access that function outside of the Tile Editor class. In the end, I edited the GridPaintPaletteWindow class. I spoke with our programmer to ask for advice, and, after showing her the package and explaining my thought process, she agreed that editing that class was the most reasonable for adding shortcuts.
